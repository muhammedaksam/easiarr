/**
 * Caddy Configuration Generator
 * Generates Caddyfile for automatic HTTPS reverse proxy
 */

import { mkdir, writeFile } from "node:fs/promises"
import { existsSync } from "node:fs"
import { join } from "node:path"
import type { EasiarrConfig } from "../config/schema"
import { getApp } from "../apps/registry"
import { debugLog } from "../utils/debug"

/**
 * Generate Caddyfile content for enabled apps
 */
export function generateCaddyfile(config: EasiarrConfig): string {
  const domain = config.caddy?.domain || "localhost"
  const email = config.caddy?.email

  let caddyfile = `# Caddyfile
# Generated by easiarr - https://github.com/muhammedaksam/easiarr
#
# Caddy provides automatic HTTPS via Let's Encrypt.
# For local dev, use 'localhost' or ':80' as domain.
#
# To manually reload: docker exec caddy caddy reload --config /etc/caddy/Caddyfile

`

  // Global options block (if email is set for ACME)
  if (email) {
    caddyfile += `{
  email ${email}
}

`
  }

  // Get enabled apps that should be proxied
  const proxyApps = config.apps.filter((app) => {
    if (!app.enabled) return false
    // Skip caddy itself and apps without ports
    if (app.id === "caddy" || app.id === "cloudflared") return false
    const def = getApp(app.id)
    if (!def || def.defaultPort === 0) return false
    return true
  })

  // Generate reverse proxy blocks for each app
  for (const app of proxyApps) {
    const def = getApp(app.id)
    if (!def) continue

    const port = app.port ?? def.defaultPort
    const subdomain = app.id
    const internalPort = def.internalPort ?? port

    // Format: subdomain.domain.com
    const host = domain === "localhost" ? `${subdomain}.localhost` : `${subdomain}.${domain}`

    caddyfile += `# ${def.name}
${host} {
  reverse_proxy ${app.id}:${internalPort}
}

`
  }

  return caddyfile
}

/**
 * Save Caddyfile to the config directory
 */
export async function saveCaddyConfig(config: EasiarrConfig): Promise<string> {
  // Check if Caddy is enabled
  const caddyApp = config.apps.find((a) => a.id === "caddy" && a.enabled)
  if (!caddyApp) {
    debugLog("Caddy", "Caddy not enabled, skipping config generation")
    return ""
  }

  const caddyDir = join(config.rootDir, "config", "caddy")
  const dataDir = join(caddyDir, "data")
  const configDir = join(caddyDir, "config")

  debugLog("Caddy", `Generating Caddyfile in ${caddyDir}`)

  try {
    // Create directories if they don't exist
    if (!existsSync(caddyDir)) {
      await mkdir(caddyDir, { recursive: true })
    }
    if (!existsSync(dataDir)) {
      await mkdir(dataDir, { recursive: true })
    }
    if (!existsSync(configDir)) {
      await mkdir(configDir, { recursive: true })
    }

    // Generate Caddyfile
    const caddyfileContent = generateCaddyfile(config)
    const caddyfilePath = join(caddyDir, "Caddyfile")

    // Always overwrite Caddyfile to reflect current app config
    await writeFile(caddyfilePath, caddyfileContent, "utf-8")
    debugLog("Caddy", `Saved Caddyfile to ${caddyfilePath}`)

    return caddyfilePath
  } catch (error) {
    const err = error as NodeJS.ErrnoException
    if (err.code === "EACCES") {
      console.warn(
        `[WARN] Cannot write Caddy config files (permission denied). ` +
          `Fix with: sudo chown -R $(id -u):$(id -g) ${caddyDir}`
      )
    } else {
      throw error
    }
    return ""
  }
}

/**
 * Get the path to the Caddyfile
 */
export function getCaddyfilePath(config: EasiarrConfig): string {
  return join(config.rootDir, "config", "caddy", "Caddyfile")
}
